//! An implementation of Knuth-Platt
//! generated by Claude Code and based on:
//! <https://github.com/jaroslov/knuth-plass-thoughts/blob/master/plass.md>

/// Trait for items that can be laid out in lines
pub trait LayoutItem {
    /// Width of this item in layout units (e.g., millimeters or points)
    fn width(&self) -> f32;
}

/// Entry in the dynamic programming table for line breaking
#[derive(Debug, Clone)]
struct BreakEntry {
    /// Best score from this point to the end of the paragraph
    score: f32,
    /// Index of the next break point in the optimal solution
    next_break: Option<usize>,
}

impl BreakEntry {
    fn unsolved() -> Self {
        Self {
            score: -1.0,
            next_break: None,
        }
    }

    fn is_solved(&self) -> bool {
        self.score >= 0.0
    }
}

/// Find optimal line breaks using the Knuth-Plass algorithm
///
/// Returns a vector of indices where line breaks should occur.
/// These indices point to the first item of each new line.
///
/// # Arguments
/// * `items` - The items to break into lines
/// * `ideal_width` - Target width for each line
/// * `max_width` - Maximum allowed width for a line
///
/// # Algorithm
/// Uses dynamic programming to find globally optimal breaks that minimize
/// total badness, where badness = (ideal_width - actual_width)Â²
pub fn find_line_breaks<T: LayoutItem>(
    items: &[T],
    ideal_width: f32,
    max_width: f32,
) -> Vec<usize> {
    if items.is_empty() {
        return vec![];
    }

    // Initialize DP table
    let mut entries: Vec<BreakEntry> = vec![BreakEntry::unsolved(); items.len()];

    // Solve starting from index 0
    solve_breaks(items, &mut entries, 0, ideal_width, max_width);

    // Extract break points by following the chain
    let mut breaks = vec![];
    let mut current = 0;

    while current < items.len() {
        if let Some(next) = entries[current].next_break {
            breaks.push(next);
            current = next;
        } else {
            // Last line - no more breaks
            break;
        }
    }

    breaks
}

/// Recursively solve the optimal line breaking problem from a given index
fn solve_breaks<T: LayoutItem>(
    items: &[T],
    entries: &mut [BreakEntry],
    idx: usize,
    ideal_width: f32,
    max_width: f32,
) {
    // Already solved this subproblem
    if entries[idx].is_solved() {
        return;
    }

    let mut jdx = idx;
    let mut line_width = 0.0;
    let mut best_score = f32::MAX;
    let mut best_break = None;

    // Try progressively longer lines starting from idx
    while jdx < items.len() {
        let item_width = items[jdx].width();

        // Check if adding this item would exceed max width
        let new_width = if jdx == idx {
            item_width // First item on line
        } else {
            line_width + 1.0 + item_width // Add space + item
        };

        if new_width > max_width {
            break; // Line too long, stop trying
        }

        line_width = new_width;
        jdx += 1;

        // Calculate badness of this line
        let line_score = {
            let diff = ideal_width - line_width;
            diff * diff
        };

        // Check if this is the last line
        if jdx >= items.len() {
            // Last line doesn't contribute to badness
            if line_score < best_score {
                best_score = 0.0;
                best_break = None; // No more breaks needed
            }
        } else {
            // Recursively solve the rest of the paragraph
            if !entries[jdx].is_solved() {
                solve_breaks(items, entries, jdx, ideal_width, max_width);
            }

            // Total score is this line + the rest
            let total_score = line_score + entries[jdx].score;

            if total_score < best_score {
                best_score = total_score;
                best_break = Some(jdx);
            }
        }
    }

    // Record the best solution for this subproblem
    entries[idx].score = best_score;
    entries[idx].next_break = best_break;
}

#[cfg(test)]
mod tests {
    use super::*;

    // Simple test item with fixed width
    struct TestItem {
        width: f32,
    }

    impl LayoutItem for TestItem {
        fn width(&self) -> f32 {
            self.width
        }
    }

    #[test]
    fn test_simple_break() {
        let items = vec![
            TestItem { width: 5.0 },
            TestItem { width: 5.0 },
            TestItem { width: 5.0 },
        ];

        let breaks = find_line_breaks(&items, 10.0, 15.0);

        // Should break after second item (5 + 1 + 5 = 11, then 5 on next line)
        assert_eq!(breaks, vec![2]);
    }

    #[test]
    fn test_no_breaks_needed() {
        let items = vec![TestItem { width: 3.0 }, TestItem { width: 3.0 }];

        let breaks = find_line_breaks(&items, 10.0, 15.0);

        // All fits on one line
        let expected: Vec<usize> = vec![];
        assert_eq!(breaks, expected);
    }

    #[test]
    fn test_empty_input() {
        let items: Vec<TestItem> = vec![];
        let breaks = find_line_breaks(&items, 10.0, 15.0);
        assert_eq!(breaks, Vec::<usize>::new());
    }
}
